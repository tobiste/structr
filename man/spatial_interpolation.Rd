% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/spatial_interpolation.R
\name{spatial_interpolation}
\alias{spatial_interpolation}
\title{Spatial interpolation}
\usage{
spatial_interpolation(
  x,
  coords,
  grid = NULL,
  lon_range = NULL,
  lat_range = NULL,
  gridsize = 0.1,
  min_data = 3,
  threshold = Inf,
  arte_thres = 100,
  dist_weight = c("inverse", "linear"),
  idp = 1,
  dist_threshold = 0.01,
  R_range = seq(1, 10, 1),
  compact = TRUE
)
}
\arguments{
\item{x}{numeric vector, array, or object of class \code{"line"} or \code{"plane"}}

\item{coords}{a \code{"sf"} object containing the geographic coordinates of \code{x}
measurements}

\item{grid}{(optional) Point object of class \code{"sf"}.`}

\item{lon_range, lat_range}{two column vector. coordinate range. ignored when
grid is specified.}

\item{gridsize}{Numeric. Target spacing of the regular grid in decimal
degree. Default is \code{2.5}. (is ignored if grid is specified)}

\item{min_data}{Integer. Minimum number of data per kernel. Default is \code{3}}

\item{threshold}{Numeric. Threshold for deviation of direction. Default is \code{25}}

\item{arte_thres}{Numeric. Maximum distance (in km) of the grid point to the
next data point. Default is \code{200}}

\item{dist_weight}{Distance weighting method which should be used:
\code{"linear"}, or \code{"inverse"} (the default).}

\item{idp}{Numeric. The weighting power of inverse distance. When set to \code{0},
no weighting is applied.}

\item{dist_threshold}{Numeric. Distance weight to prevent overweight of data
nearby (0 to 1). Default is \code{0.1}}

\item{R_range}{Numeric value or vector specifying the kernel half-width, i.e.
the search radius (in km). Default is \code{1}}

\item{compact}{logical.}
}
\value{
list
}
\description{
Inverse distance weighted spatial interpolation of plane or line objects.
}
\details{
Based on \code{\link[tectonicr:stress2grid]{tectonicr::stress2grid()}}
}
\examples{
\dontrun{
data <- read_strabo_JSON("E:/Lakehead/Field work/StraboSpot_07_02_2023.json")
ps <- data$data |>
  dplyr::mutate(dipdir = (strike + 90) \%\% 360) |>
  dplyr::filter(type == "planar_orientation" &
    !(feature_type \%in\% c("other", "vector", "option_13")))

ps_vec <- structr::as.plane(cbind(ps$dipdir, ps$dip))

spatial_interpolation(
  x = ps_vec, coords = ps, gridsize = .05, R_range = seq(1, 10, 1),
  dist_threshold = 0.01, threshold = Inf
)
}
}
\seealso{
\code{\link[tectonicr:stress2grid]{tectonicr::stress2grid()}}, \code{\link[=v_mean]{v_mean()}}, \code{\link[=v_delta]{v_delta()}}
}
